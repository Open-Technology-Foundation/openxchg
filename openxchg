#!/bin/bash
# openxchg - Multi-currency exchange rate database manager
#
# Fetches exchange rates from openexchangerates.org API and stores them in
# a SQLite database. Supports multiple base currencies with separate tables
# for each. Currency codes are case-insensitive. Options can appear anywhere
# in the command line (GNU-style argument parsing).
#
# Database: xchg.db (SQLite)
# Tables: One table per base currency (e.g., IDR, USD, EUR, GBP)
# Supported: 169 currencies from OpenExchange API

set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

declare -r VERSION='1.0.0'
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -e -- "$0")
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*} SCRIPT_NAME=${SCRIPT_PATH##*/}

# Configuration file settings
declare -r SYSTEM_CONFIG_FILE="/etc/openxchg/config"
declare -- CONFIG_FILE="${HOME}/.config/openxchg/config"
declare -- CONFIG_DIR="${HOME}/.config/openxchg"
declare -- CURRENCIES_FILE="${CONFIG_DIR}/currencies.json"
declare -- CONFIG_DEFAULT_BASE_CURRENCY=""
declare -- CONFIG_DEFAULT_VERBOSE=""
declare -- CONFIG_DEFAULT_DATE=""
declare -- CONFIG_API_KEY=""
declare -- CONFIG_DB_PATH=""
declare -- CONFIG_AUTO_UPDATE_CURRENCY_LIST=""
declare -- CONFIG_UPDATE_CURRENCIES=""

declare -- DB_PATH="$SCRIPT_DIR"/xchg.db

declare -r OPENEXCHANGE_HISTORICAL_URL='https://openexchangerates.org/api/historical/'
declare -r OPENEXCHANGE_LATEST_URL='https://openexchangerates.org/api/latest.json'
declare -- OPENEXCHANGE_API_KEY=${OPENEXCHANGE_API_KEY:-'2a9989da6985438481f9a5f3801d84d1'}

declare -a MU=( AED AFN ALL AMD ANG AOA ARS AUD AWG AZN BAM BBD BDT BGN BHD BIF BMD BND BOB BRL BSD BTC BTN BWP BYN BZD CAD CDF CHF CLF CLP CNH CNY COP CRC CUC CUP CVE CZK DJF DKK DOP DZD EGP ERN ETB EUR FJD FKP GBP GEL GGP GHS GIP GMD GNF GTQ GYD HKD HNL HRK HTG HUF IDR ILS IMP INR IQD IRR ISK JEP JMD JOD JPY KES KGS KHR KMF KPW KRW KWD KYD KZT LAK LBP LKR LRD LSL LYD MAD MDL MGA MKD MMK MNT MOP MRU MUR MVR MWK MXN MYR MZN NAD NGN NIO NOK NPR NZD OMR PAB PEN PGK PHP PKR PLN PYG QAR RON RSD RUB RWF SAR SBD SCR SDG SEK SGD SHP SLL SOS SRD SSP STD STN SVC SYP SZL THB TJS TMT TND TOP TRY TTD TWD TZS UAH UGX USD UYU UZS VND VUV WST XAF XAG XAU XCD XDR XOF XPD XPF XPT YER ZAR ZMW ZWL )

declare -r TMPFILE=/tmp/"$SCRIPT_NAME"-"$RANDOM"-"$$"

declare -i VERBOSE=1
declare -i LATEST_MODE=0
declare -i UPDATE_ALL_CURRENCIES=0

trap '{ cleanup $?; }' EXIT


# Color definitions
if [[ -t 1 && -t 2 ]]; then
  declare -r RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' BOLD='\033[1m' NC=$'\033[0m'
else
  declare -r RED='' GREEN='' YELLOW='' CYAN='' BOLD='' NC=''
fi

# Utility functions
_msg() {
  local -- status="${FUNCNAME[1]}" prefix="$SCRIPT_NAME:" msg
  case "$status" in
    info)    : ;; #prefix+=" ${CYAN}◉${NC}" ;;
    warn)    prefix+=" ${YELLOW}▲${NC}" ;;
    success) prefix+=" ${GREEN}✓${NC}" ;;
    error)   prefix+=" ${RED}✗${NC}" ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}

info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
success() { ((VERBOSE)) || return 0; >&2 _msg "$@" || return 0; }
error() { >&2 _msg "$@"; }
die() { (($# > 1)) && error "${@:2}"; exit "${1:-0}"; }

#
# load_config - Load and parse INI-style configuration file
#
# Reads configuration from INI file with sections and key=value pairs.
# Supports comments (# and ;) and blank lines. Permissive error handling:
# warns on invalid lines but continues with defaults.
#
# Arguments:
#   $1 - Path to config file
#   $2 - (Optional) If "fallback", only set values that aren't already set
#
# Sets global variables:
#   CONFIG_DEFAULT_BASE_CURRENCY
#   CONFIG_DEFAULT_VERBOSE
#   CONFIG_DEFAULT_DATE
#   CONFIG_API_KEY
#   CONFIG_DB_PATH
#
load_config() {
  local -- config_file="$1"
  local -- mode="${2:-normal}"
  local -- section="" key value line

  [[ -f "$config_file" ]] || return 0
  [[ -r "$config_file" ]] || return 0  # Silently skip if not readable

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Remove leading/trailing whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    # Skip empty lines and comments
    [[ -n "$line" ]] || continue
    [[ ! "$line" =~ ^[#\;] ]] || continue

    # Section headers
    if [[ "$line" =~ ^\[([^]]+)\]$ ]]; then
      section="${BASH_REMATCH[1]}"
      continue
    fi

    # Key=value pairs
    if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"

      # Trim whitespace from key and value
      key="${key#"${key%%[![:space:]]*}"}"
      key="${key%"${key##*[![:space:]]}"}"
      value="${value#"${value%%[![:space:]]*}"}"
      value="${value%"${value##*[![:space:]]}"}"

      # Map to global config variables (skip if already set in fallback mode)
      case "$section:$key" in
        General:DEFAULT_BASE_CURRENCY)
          if [[ "$mode" == "fallback" && -n "${CONFIG_DEFAULT_BASE_CURRENCY}" ]]; then
            continue
          fi
          CONFIG_DEFAULT_BASE_CURRENCY="${value^^}"
          ;;
        General:DEFAULT_VERBOSE)
          if [[ "$mode" == "fallback" && -n "${CONFIG_DEFAULT_VERBOSE}" ]]; then
            continue
          fi
          if [[ "$value" =~ ^[01]$ ]]; then
            CONFIG_DEFAULT_VERBOSE="$value"
          else
            warn "Invalid DEFAULT_VERBOSE value ${value@Q} in config (must be 0 or 1), using default"
          fi
          ;;
        General:DEFAULT_DATE)
          if [[ "$mode" == "fallback" && -n "${CONFIG_DEFAULT_DATE}" ]]; then
            continue
          fi
          CONFIG_DEFAULT_DATE="$value"
          ;;
        General:AUTO_UPDATE_CURRENCY_LIST)
          if [[ "$mode" == "fallback" && -n "${CONFIG_AUTO_UPDATE_CURRENCY_LIST}" ]]; then
            continue
          fi
          if [[ "$value" =~ ^(true|false)$ ]]; then
            CONFIG_AUTO_UPDATE_CURRENCY_LIST="$value"
          else
            warn "Invalid AUTO_UPDATE_CURRENCY_LIST value ${value@Q} in config (must be true or false), using default"
          fi
          ;;
        General:UPDATE_CURRENCIES)
          if [[ "$mode" == "fallback" && -n "${CONFIG_UPDATE_CURRENCIES}" ]]; then
            continue
          fi
          CONFIG_UPDATE_CURRENCIES="$value"
          ;;
        API:API_KEY)
          if [[ "$mode" == "fallback" && -n "${CONFIG_API_KEY}" ]]; then
            continue
          fi
          CONFIG_API_KEY="$value"
          ;;
        Database:DB_PATH)
          if [[ "$mode" == "fallback" && -n "${CONFIG_DB_PATH}" ]]; then
            continue
          fi
          CONFIG_DB_PATH="$value"
          ;;
        *)
          warn "Unknown config option ${section@Q}:${key@Q} in ${config_file@Q}"
          ;;
      esac
    else
      warn "Invalid config line in ${config_file@Q}: ${line@Q}"
    fi
  done < "$config_file"
}

#
# create_default_config - Create default configuration file
#
# Creates a well-commented default config file at the specified path.
# If file exists, creates a backup with .bak extension.
#
# Arguments:
#   $1 - Path to config file to create
#
create_default_config() {
  local -- config_file="$1"
  local -- config_dir="${config_file%/*}"

  # Create config directory if it doesn't exist
  if [[ ! -d "$config_dir" ]]; then
    mkdir -p "$config_dir" || die 1 "Failed to create config directory ${config_dir@Q}"
    info "Created config directory ${config_dir@Q}"
  fi

  # Backup existing config file
  if [[ -f "$config_file" ]]; then
    cp "$config_file" "$config_file.bak" || die 1 "Failed to backup existing config"
    info "Backed up existing config to $config_file.bak"
  fi

  # Create default config file
  cat > "$config_file" <<'EOF'
# openxchg configuration file
# This file uses INI-style format with [Sections] and key=value pairs
# Lines starting with # or ; are comments

[General]
# Default base currency (3-letter ISO code, case-insensitive)
# This is used when no base currency is specified on command line
# Default: IDR
DEFAULT_BASE_CURRENCY=IDR

# Default verbosity (0=quiet, 1=verbose)
# Controls whether progress messages are displayed
# Default: 1
DEFAULT_VERBOSE=1

# Default date for queries/updates
# Options: yesterday, today, or specific date (YYYY-MM-DD)
# Note: API requires historical dates, 'today' may not have data yet
# Default: yesterday
DEFAULT_DATE=yesterday

# Auto-update currency list from API
# If true, automatically fetches latest currency list once per day
# Requires currencies.json to exist (create with: openxchg -U)
# Default: true
AUTO_UPDATE_CURRENCY_LIST=true

# Which currencies to update in UPDATE mode
# Options:
#   ALL                                        - Update all currencies (default)
#   CONFIGURED                                 - Use currencies from currencies.json
#   /path/to/update-currencies.list           - Custom list file (one currency per line)
# Note: This only affects UPDATE mode. QUERY mode can access any currency in database.
# Tip: Use 'openxchg --init-config' to create update-currencies.list.example
# Default: ALL
UPDATE_CURRENCIES=ALL

[API]
# OpenExchangeRates API key
# Precedence: CLI option (-a/--apikey) > Environment variable (OPENEXCHANGE_API_KEY) > This file
# SECURITY: If set here, ensure this file has mode 0600 (chmod 600 config)
# Recommended: Leave empty and use environment variable instead
# Default: (empty - uses environment variable)
API_KEY=

[Database]
# Database file location
# Can be absolute path or relative to script directory
# Default: xchg.db (in script directory)
DB_PATH=xchg.db

# Usage examples:
#   DB_PATH=xchg.db                    # Same directory as script
#   DB_PATH=/var/lib/openxchg/xchg.db  # Absolute path
#   DB_PATH=~/.local/share/openxchg/xchg.db  # User's home directory
EOF

  chmod 600 "$config_file" || die 1 "Failed to set permissions on config file"

  info "Created default config file: $config_file"
  info "File permissions set to 0600 (owner read/write only)"
  echo
  info "Edit this file to customize your defaults, or use command-line options to override."
}

#
# create_default_currency_list - Create example currency list file
#
# Creates a well-commented example update-currencies.list file with
# commonly used currencies. File is created as .example to prevent
# accidental activation.
#
create_default_currency_list() {
  local -- list_file="${CONFIG_DIR}/update-currencies.list.example"

  # Create config directory if needed
  [[ -d "$CONFIG_DIR" ]] || mkdir -p "$CONFIG_DIR"

  # Create example currency list
  cat > "$list_file" <<'EOF'
# openxchg - Currency Update List
#
# This file defines which currencies to update in UPDATE mode.
# One currency code per line (3-letter ISO codes, case-insensitive).
# Lines starting with # are comments and blank lines are ignored.
#
# To activate:
#   1. Copy this file: cp update-currencies.list.example update-currencies.list
#   2. Edit to add/remove currencies as needed
#   3. Update config file: UPDATE_CURRENCIES=/path/to/update-currencies.list
#   4. Run update: openxchg idr
#
# Note: QUERY mode can still access any currency in the database,
#       regardless of what's in this list.

# Major world currencies
USD    # United States Dollar
EUR    # Euro
GBP    # British Pound Sterling
JPY    # Japanese Yen
CNY    # Chinese Yuan

# Asia-Pacific
IDR    # Indonesian Rupiah
AUD    # Australian Dollar
SGD    # Singapore Dollar
MYR    # Malaysian Ringgit
THB    # Thai Baht

# Add more currencies as needed...
# See currencies.json for full list of 173 currencies
EOF

  chmod 600 "$list_file" 2>/dev/null || true

  info "Created example currency list: $list_file"
}

#
# validate_config - Validate configuration file(s)
#
# Performs comprehensive validation of configuration files at multiple levels:
#   1. Syntax validation - Proper INI format
#   2. Value validation - Valid currency codes, paths, etc.
#   3. Best practices - Security and performance warnings
#   4. Dependency checks - Required commands and files
#
# Arguments:
#   $1 - Config file path to validate
#
# Returns:
#   0 if validation passed (warnings allowed)
#   1 if validation failed (errors found)
#
validate_config() {
  local -- config_file="${1:-$CONFIG_FILE}"
  local -i errors=0 warnings=0 info=0
  local -- section="" line key value
  local -i line_num=0

  info "Validating Configuration: $config_file" "========================================" ''

  # Check if file exists
  if [[ ! -f "$config_file" ]]; then
    error "Config file not found: $config_file"
    return 1
  fi

  # Check if file is readable
  if [[ ! -r "$config_file" ]]; then
    error "Config file not readable: $config_file"
    return 1
  fi

  info "File: $config_file" \
       "Size: $(stat -c%s "$config_file") bytes"

  # 1. SYNTAX VALIDATION
  info "1. Syntax Validation" "--------------------"

  while IFS= read -r line || [[ -n "$line" ]]; do
    line_num+=1

    # Skip empty lines and comments
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue
    [[ "$line" =~ ^[[:space:]]*[#\;] ]] && continue

    # Check for section header
    if [[ "$line" =~ ^\[([A-Za-z0-9_]+)\][[:space:]]*$ ]]; then
      section="${BASH_REMATCH[1]}"

      # Validate section name
      case "$section" in
        General|API|Database)
          : # Valid section
          ;;
        *)
          warn "Line $line_num: Unknown section [$section]"
          warnings+=1
          ;;
      esac
      continue
    fi

    # Check for key=value pair
    if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"

      # Validate key format
      if [[ ! "$key" =~ ^[A-Z_][A-Z0-9_]*$ ]]; then
        warn "Line $line_num: Key should be UPPERCASE_WITH_UNDERSCORES: $key"
        ((warnings+=1))
      fi

      continue
    fi

    # Line doesn't match any valid format
    error "Line $line_num: Invalid syntax: ${line:0:60}"
    ((errors+=1))
  done < "$config_file"

  if ((errors == 0 && warnings == 0)); then
    success "Syntax validation passed"
  elif ((errors > 0)); then
    error "Syntax validation failed: $errors error(s), $warnings warning(s)"
  else
    success "Syntax validation passed with $warnings warning(s)"
  fi

  # 2. VALUE VALIDATION
  info "2. Value Validation" "-------------------"

  section=""
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip empty lines and comments
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue
    [[ "$line" =~ ^[[:space:]]*[#\;] ]] && continue

    # Track section
    if [[ "$line" =~ ^\[([A-Za-z0-9_]+)\] ]]; then
      section="${BASH_REMATCH[1]}"
      continue
    fi

    # Parse key=value
    if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"

      case "$section:$key" in
        General:DEFAULT_BASE_CURRENCY)
          if [[ -n "$value" ]]; then
            value="${value^^}"
            if [[ ! "$value" =~ ^[A-Z]{3}$ ]]; then
              error "DEFAULT_BASE_CURRENCY must be 3-letter code: $value"
              ((errors+=1))
            elif [[ ! " ${MU[*]} " =~ " $value " ]]; then
              error "DEFAULT_BASE_CURRENCY not supported: $value"
              ((errors+=1))
            else
              success "DEFAULT_BASE_CURRENCY: $value (valid)"
              ((info+=1))
            fi
          fi
          ;;
        General:DEFAULT_VERBOSE)
          if [[ -n "$value" ]] && [[ ! "$value" =~ ^[01]$ ]]; then
            error "DEFAULT_VERBOSE must be 0 or 1: $value"
            ((errors+=1))
          elif [[ -n "$value" ]]; then
            success "DEFAULT_VERBOSE: $value (valid)"
            ((info+=1))
          fi
          ;;
        General:DEFAULT_DATE)
          if [[ -n "$value" ]]; then
            case "$value" in
              yesterday|today)
                success "DEFAULT_DATE: $value (valid)"
                ((info+=1))
                ;;
              *)
                # Try to parse as date
                if TZ=UTC date +%F -d "$value" &>/dev/null; then
                  success "DEFAULT_DATE: $value (valid date format)"
                  ((info+=1))
                else
                  error "DEFAULT_DATE invalid: $value (use 'yesterday', 'today', or YYYY-MM-DD)"
                  ((errors+=1))
                fi
                ;;
            esac
          fi
          ;;
        General:AUTO_UPDATE_CURRENCY_LIST)
          if [[ -n "$value" ]]; then
            value="${value,,}"
            if [[ ! "$value" =~ ^(true|false)$ ]]; then
              error "AUTO_UPDATE_CURRENCY_LIST must be 'true' or 'false': $value"
              ((errors+=1))
            else
              success "AUTO_UPDATE_CURRENCY_LIST: $value (valid)"
              ((info+=1))
            fi
          fi
          ;;
        General:UPDATE_CURRENCIES)
          if [[ -n "$value" ]]; then
            case "$value" in
              ALL|CONFIGURED)
                success "UPDATE_CURRENCIES: $value (valid)"
                ((info+=1))
                ;;
              /*)
                if [[ ! -f "$value" ]]; then
                  warn "UPDATE_CURRENCIES file not found: $value"
                  ((warnings+=1))
                else
                  success "UPDATE_CURRENCIES: $value (file exists)"
                  ((info+=1))
                fi
                ;;
              *)
                error "UPDATE_CURRENCIES must be 'ALL', 'CONFIGURED', or absolute path: $value"
                ((errors+=1))
                ;;
            esac
          fi
          ;;
        Database:DB_PATH)
          if [[ -n "$value" ]]; then
            # Check if path is absolute or relative
            if [[ "$value" =~ ^/ ]]; then
              # Absolute path - check if parent directory exists
              local -- parent_dir
              parent_dir=$(dirname "$value")
              if [[ ! -d "$parent_dir" ]]; then
                warn "DB_PATH parent directory does not exist: $parent_dir"
                ((warnings+=1))
              else
                success "DB_PATH: $value (parent directory exists)"
                ((info+=1))
              fi
            else
              # Relative path is ok (relative to script directory)
              success "DB_PATH: $value (relative path)"
              ((info+=1))
            fi
          fi
          ;;
        API:API_KEY)
          # Don't validate the actual key value, just check if set
          if [[ -n "$value" ]]; then
            info "API_KEY: Set in config (****${value: -4})"
            ((info+=1))
          fi
          ;;
      esac
    fi
  done < "$config_file"

  if ((errors == 0)); then
    success "Value validation passed"
  else
    error "Value validation failed: $errors error(s)"
  fi

  # 3. BEST PRACTICES
  info "3. Best Practices" "-----------------"

  # Check file permissions
  local -- perms
  perms=$(stat -c%a "$config_file")
  if [[ "$perms" != "600" ]] && [[ "$perms" != "400" ]]; then
    # Check if API key is set in file
    if grep -q '^[[:space:]]*API_KEY=.' "$config_file"; then
      warn "Config contains API_KEY but is not mode 600/400 (current: $perms)"
      info "  Recommendation: chmod 600 $config_file"
      ((warnings+=1))
    else
      info "File permissions: $perms (acceptable, no API key in file)"
      ((info+=1))
    fi
  else
    success "File permissions: $perms (secure)"
    ((info+=1))
  fi

  # Check if API key is in environment instead of file
  if grep -q '^[[:space:]]*API_KEY=[[:space:]]*$' "$config_file"; then
    success "API_KEY not stored in config file (using environment variable recommended)"
    ((info+=1))
  elif grep -q '^[[:space:]]*API_KEY=.' "$config_file"; then
    info "API_KEY stored in config file (environment variable is more secure)"
    ((info+=1))
  fi

  # Check UPDATE_CURRENCIES setting for performance
  if grep -q '^[[:space:]]*UPDATE_CURRENCIES=ALL' "$config_file"; then
    info "UPDATE_CURRENCIES=ALL will update all 173 currencies (consider selective list for faster updates)"
    ((info+=1))
  fi

  success "Best practices check completed"

  # 4. DEPENDENCY CHECKS
  info "4. Dependency Checks" "--------------------"

  local -a required_commands=(sqlite3 wget jq bc date)
  local -i missing=0

  for cmd in "${required_commands[@]}"; do
    if command -v "$cmd" &>/dev/null; then
      success "$cmd: Available"
    else
      error "Required command not found: $cmd"
      ((errors+=1))
      ((missing+=1))
    fi
  done

  if ((missing == 0)); then
    success "All dependencies available"
  else
    error "Dependency check failed: $missing missing command(s)"
  fi
  echo

  # SUMMARY
  info "Summary" "-------" \
       "Errors:   $errors" \
       "Warnings: $warnings" \
       "Info:     $info"

  if ((errors > 0)); then
    error "VALIDATION FAILED"
    return 1
  elif ((warnings > 0)); then
    success "VALIDATION PASSED (with warnings)"
    return 0
  else
    success "VALIDATION PASSED"
    return 0
  fi
}

#
# show_config - Display current effective configuration
#
# Shows the effective configuration from all sources (CLI, config file, env, defaults)
# with indication of which source each value comes from.
#
show_config() {
  local -- base_source verbose_source date_source dbpath_source autoupdate_source updatecurr_source

  info "Current Configuration (effective values)" "========================================" ''

  info "System Config File: ${SYSTEM_CONFIG_FILE}"
  if [[ -f "${SYSTEM_CONFIG_FILE}" ]]; then
    if [[ -r "${SYSTEM_CONFIG_FILE}" ]]; then
      info "  Status: Found and readable"
    else
      info "  Status: Found but not readable (insufficient permissions)"
    fi
  else
    info "  Status: Not found"
  fi

  info "User Config File: ${CONFIG_FILE}"
  [[ -f "${CONFIG_FILE}" ]] && info "  Status: Found" || info "  Status: Not found"

  # Determine sources
  [[ -n "${CONFIG_DEFAULT_BASE_CURRENCY}" ]] && base_source="config" || base_source="default"
  [[ -n "${CONFIG_DEFAULT_VERBOSE}" ]] && verbose_source="config" || verbose_source="default"
  [[ -n "${CONFIG_DEFAULT_DATE}" ]] && date_source="config" || date_source="default"
  [[ -n "${CONFIG_DB_PATH}" ]] && dbpath_source="config" || dbpath_source="default"
  [[ -n "${CONFIG_AUTO_UPDATE_CURRENCY_LIST}" ]] && autoupdate_source="config" || autoupdate_source="default"
  [[ -n "${CONFIG_UPDATE_CURRENCIES}" ]] && updatecurr_source="config" || updatecurr_source="default"

  info "Settings:"
  info "  DEFAULT_BASE_CURRENCY: ${CONFIG_DEFAULT_BASE_CURRENCY:-IDR} ($base_source)"
  info "  DEFAULT_VERBOSE: ${CONFIG_DEFAULT_VERBOSE:-1} ($verbose_source)"
  info "  DEFAULT_DATE: ${CONFIG_DEFAULT_DATE:-yesterday} ($date_source)"
  info "  AUTO_UPDATE_CURRENCY_LIST: ${CONFIG_AUTO_UPDATE_CURRENCY_LIST:-true} ($autoupdate_source)"
  info "  UPDATE_CURRENCIES: ${CONFIG_UPDATE_CURRENCIES:-ALL} ($updatecurr_source)"
  info "  DB_PATH: ${CONFIG_DB_PATH:-$SCRIPT_DIR/xchg.db} ($dbpath_source)"

  if [[ -n "${CONFIG_API_KEY}" ]]; then
    info "  API_KEY: ****${CONFIG_API_KEY: -4} (config file)"
  elif [[ -n "${OPENEXCHANGE_API_KEY}" ]]; then
    info "  API_KEY: ****${OPENEXCHANGE_API_KEY: -4} (environment variable)"
  else
    info "  API_KEY: (not set)"
  fi

  info "Currency List: ${CURRENCIES_FILE}"
  if [[ -f "${CURRENCIES_FILE}" ]]; then
    local -i count
    count=$(jq -r '.count // 0' "$CURRENCIES_FILE" 2>/dev/null || echo 0)
    local -- last_updated
    last_updated=$(jq -r '.last_updated // "unknown"' "$CURRENCIES_FILE" 2>/dev/null || echo "unknown")
    info "  Status: Found ($count currencies) Updated: $last_updated"
  else
    warn "  Status: Not found (using hardcoded list)" \
         "  Tip: Run 'openxchg -U' to fetch latest currency list"
  fi

  info "Precedence: CLI options > User config > Environment > System config > Defaults"
}

#
# check_config_security - Check config file permissions for security issues
#
# Warns if config file is readable by group or world and contains an API key.
# Non-blocking: displays warning but allows execution to continue.
#
# Arguments:
#   $1 - Path to config file
#
check_config_security() {
  local -- config_file="$1"

  [[ -f "$config_file" ]] || return 0
  [[ -n "${CONFIG_API_KEY}" ]] || return 0

  # Check file permissions (stat -c %a gives octal mode)
  local -- perms
  perms=$(stat -c %a "$config_file" 2>/dev/null || echo "000")

  # Check if group or world readable (last two digits > 0)
  local -i group_perms=$((10#${perms:1:1}))
  local -i world_perms=$((10#${perms:2:1}))

  if ((group_perms > 0 || world_perms > 0)); then
    warn "Config file ${config_file@Q} contains API_KEY but is readable by others" \
         "  Current permissions: $perms (should be 600)" \
         "  Fix with: chmod 600 ${config_file@Q}"
  fi
}

#
# fetch_currencies - Fetch and update currency list from API
#
# Downloads the latest currency list from OpenExchangeRates API and stores
# it in currencies.json with metadata (timestamp, count, etc.)
#
fetch_currencies() {
  local -- currencies_url='https://openexchangerates.org/api/currencies.json'
  local -- temp_json="${TMPFILE}.currencies"

  info "Fetching currency list from OpenExchangeRates API..."

  # Fetch currencies from API (no API key required)
  if ! wget -q -O "$temp_json" "$currencies_url"; then
    error "Failed to fetch currency list from ${currencies_url@Q}"
    return 1
  fi

  # Verify it's valid JSON
  if ! jq empty "$temp_json" 2>/dev/null; then
    error "Invalid JSON received from currency API"
    rm -f "$temp_json"
    return 1
  fi

  # Create config directory if needed
  [[ -d "$CONFIG_DIR" ]] || mkdir -p "$CONFIG_DIR"

  # Build currencies.json with metadata
  local -- timestamp
  timestamp=$(TZ=UTC date -Iseconds)
  local -i count
  count=$(jq 'length' "$temp_json")

  # Create currencies.json with metadata wrapper
  jq -n \
    --arg timestamp "$timestamp" \
    --arg source "$currencies_url" \
    --arg version "1.0" \
    --argjson count "$count" \
    --slurpfile currencies "$temp_json" \
    '{
      last_updated: $timestamp,
      source: $source,
      version: $version,
      count: $count,
      currencies: $currencies[0]
    }' > "$CURRENCIES_FILE"

  chmod 600 "$CURRENCIES_FILE" 2>/dev/null || true

  info "Currency list updated successfully" \
       "  File: $CURRENCIES_FILE" \
       "  Count: $count currencies" \
       "  Updated: $timestamp"

  rm -f "$temp_json"
  return 0
}

#
# normalize_currency_code - Normalize currency code with alias support
#
# Converts common currency aliases to official ISO codes and uppercases.
# Supports hardcoded aliases for common currency names.
#
# Arguments:
#   $1 - Currency code or alias (e.g., renminbi, yuan, RMB)
#
# Returns:
#   Official 3-letter ISO currency code via stdout
#
normalize_currency_code() {
  local -- input="${1^^}"  # Convert to uppercase

  # Apply hardcoded aliases FIRST (case-insensitive matching done via ${1^^})
  case "$input" in
    # Chinese Yuan
    RMB|RENMINBI|YUAN)
      echo CNY
      ;;
    # Indonesian Rupiah
    RUPIAH)
      echo IDR
      ;;
    # Japanese Yen
    YEN)
      echo JPY
      ;;
    # British Pound
    STERLING|POUND)
      echo GBP
      ;;
    # US Dollar
    DOLLAR|GREENBACK)
      echo USD
      ;;
    # Swiss Franc
    FRANC|SWISSY)
      echo CHF
      ;;
    # Australian Dollar
    AUSSIE)
      echo AUD
      ;;
    # New Zealand Dollar
    KIWI)
      echo NZD
      ;;
    # Canadian Dollar
    LOONIE)
      echo CAD
      ;;
    *)
      # Not a known alias, return as-is (will be validated elsewhere)
      echo "$input"
      ;;
  esac
}

#
# load_currencies - Load currency list from JSON file
#
# Loads currencies from currencies.json into MU array. Falls back to
# hardcoded list if file doesn't exist or is invalid.
#
# Sets global variable:
#   MU - Array of currency codes
#
load_currencies() {
  # If currencies.json exists and is valid, load from it
  if [[ -f "$CURRENCIES_FILE" ]] && jq empty "$CURRENCIES_FILE" 2>/dev/null; then
    # Extract currency codes as array
    local -- codes
    codes=$(jq -r '.currencies | keys[]' "$CURRENCIES_FILE" 2>/dev/null | tr '\n' ' ')
    if [[ -n "$codes" ]]; then
      # shellcheck disable=SC2206
      MU=($codes)
      return 0
    fi
  fi
  # Fallback to hardcoded list
  info "Using hardcoded currency list (${#MU[@]} currencies)"
  return 0
}

#
# get_currency_name - Get full name for currency code
#
# Arguments:
#   $1 - Currency code (e.g., USD)
#
# Returns:
#   Currency name from currencies.json, or empty string if not found
#
get_currency_name() {
  local -- code="$1"

  [[ -f "$CURRENCIES_FILE" ]] || return 0
  jq -r --arg code "$code" '.currencies[$code] // ""' "$CURRENCIES_FILE" 2>/dev/null || echo ''
}

#
# load_update_currency_list - Load currency codes from file
#
# Reads a file containing one currency code per line (comments and blank lines ignored).
# Validates all currencies exist in the MU array. Fails with error if any invalid.
#
# Arguments:
#   $1 - Path to currency list file
#
# Returns:
#   Space-separated list of uppercase currency codes via stdout
#
load_update_currency_list() {
  local -- list_file="$1"
  local -- line code
  local -a codes=()

  [[ -f "$list_file" ]] || die 1 "Currency list file not found: ${list_file@Q}"

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Remove leading/trailing whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    # Skip empty lines and comments
    [[ -n "$line" ]] || continue
    [[ ! "$line" =~ ^# ]] || continue

    # Extract currency code (first word, before any comment)
    code="${line%%[[:space:]#]*}"
    code=$(normalize_currency_code "$code")

    # Validate it's a 3-letter code (after normalization)
    [[ "$code" =~ ^[A-Z]{3}$ ]] || die 1 "Invalid currency code/alias ${line%%[[:space:]#]*@Q} in ${list_file@Q} (unknown currency)"

    # Validate currency exists in MU array
    [[ " ${MU[*]} " =~ " ${code} " ]] || die 1 "Currency ${code@Q} in ${list_file@Q} not supported by API (run 'openxchg -U' to update currency list)"

    codes+=("$code")
  done < "$list_file"

  ((${#codes[@]} > 0)) || die 1 "No valid currencies found in ${list_file@Q}"

  echo "${codes[*]}"
}

#
# get_update_currency_list - Get list of currencies to update
#
# Determines which currencies to update based on UPDATE_CURRENCIES config
# and --all flag. Returns space-separated list of currency codes.
#
# Globals:
#   CONFIG_UPDATE_CURRENCIES - Config setting (ALL, CONFIGURED, or file path)
#   UPDATE_ALL_CURRENCIES - Flag from --all option
#   MU - Array of all supported currencies
#
# Returns:
#   Space-separated list of currency codes via stdout
#
get_update_currency_list() {
  local -- setting="${CONFIG_UPDATE_CURRENCIES:-ALL}"

  # --all flag overrides config
  if ((UPDATE_ALL_CURRENCIES)); then
    info "Using --all flag: updating all ${#MU[@]} currencies"
    echo "${MU[*]}"
    return 0
  fi

  case "$setting" in
    ALL)
      echo "${MU[*]}"
      ;;
    CONFIGURED)
      # Use currencies from currencies.json
      if [[ -f "$CURRENCIES_FILE" ]]; then
        local -- codes
        codes=$(jq -r '.currencies | keys[]' "$CURRENCIES_FILE" 2>/dev/null | tr '\n' ' ')
        if [[ -n "$codes" ]]; then
          echo "$codes"
        else
          die 1 "UPDATE_CURRENCIES=CONFIGURED but no currencies found in ${CURRENCIES_FILE@Q}"
        fi
      else
        die 1 "UPDATE_CURRENCIES=CONFIGURED but ${CURRENCIES_FILE@Q} not found (run 'openxchg -U' to create it)"
      fi
      ;;
    /*)
      # Absolute path to custom file
      load_update_currency_list "$setting"
      ;;
    ~*)
      # Home-relative path (expand tilde)
      load_update_currency_list "${setting/#\~/$HOME}"
      ;;
    *)
      # Relative path (relative to CONFIG_DIR)
      load_update_currency_list "${CONFIG_DIR}/${setting}"
      ;;
  esac
}

#
# check_auto_update_currencies - Auto-update currencies if needed
#
# Checks if currencies.json needs updating based on AUTO_UPDATE_CURRENCY_LIST
# config and last update timestamp. Updates if last update was not today.
#
check_auto_update_currencies() {
  # Skip if auto-update is disabled
  [[ "${CONFIG_AUTO_UPDATE_CURRENCY_LIST}" == "true" ]] || return 0

  # Skip if currencies file doesn't exist (will be created on first -U)
  [[ -f "$CURRENCIES_FILE" ]] || return 0

  # Get last update date
  local -- last_update
  last_update=$(jq -r '.last_updated // ""' "$CURRENCIES_FILE" 2>/dev/null)
  [[ -n "$last_update" ]] || return 0

  # Extract date portion (YYYY-MM-DD)
  local -- last_date="${last_update:0:10}"
  local -- today
  today=$(TZ=UTC date +%F)

  # Update if last update was not today
  if [[ "$last_date" != "$today" ]]; then
    info "Auto-updating currency list (last update: $last_date)..."
    fetch_currencies
  fi
}

#
# ensure_table_exists - Create currency table if it doesn't exist
#
# Validates currency code format and API support, then creates a SQLite table
# for the specified currency if it doesn't already exist. Each table stores
# exchange rates with columns: id, Date, Currency, Unit, Xchg, Updated.
#
# Arguments:
#   $1 - Currency code (must be 3 uppercase letters from MU array)
#
ensure_table_exists() {
  local -- currency=${1^^}

  # Validate currency code (3 uppercase letters)
  [[ $currency =~ ^[A-Z]{3}$ ]] || die 1 "Invalid currency code: ${currency@Q} (must be 3 uppercase letters)"

  # Validate currency is supported by API
  [[ " ${MU[*]} " =~ " ${currency} " ]] || die 1 "Currency ${currency@Q} not supported by API (see MU array)"

  # Check if table exists
  local -i exists
  exists=$(sqlite3 "$DB_PATH" \
    "SELECT COUNT(*) FROM sqlite_master
     WHERE type='table' AND name='$currency'" 2>/dev/null || echo 0)

  if ((exists == 0)); then
    # Create table with standard schema
    info "Creating new table: $currency"
    sqlite3 "$DB_PATH" <<EOF
CREATE TABLE $currency (
  id INTEGER PRIMARY KEY,
  Date DATE NOT NULL,
  Currency TEXT NOT NULL DEFAULT 'USD',
  Unit INTEGER NOT NULL DEFAULT 1,
  Xchg REAL NOT NULL DEFAULT 0.0,
  Updated TIMESTAMP NOT NULL,
  UNIQUE(Date, Currency)
);
CREATE INDEX idx_${currency}_currency ON $currency(Currency);
CREATE INDEX idx_${currency}_updated ON $currency(Updated);
EOF
    info "Table $currency created successfully"
  fi
}

#
# db_info - Display database statistics and information
#
# Shows comprehensive information about the database including:
#   - Database file location, size, and modification time
#   - List of all currency tables
#   - Record counts per table
#   - Date ranges for each table
#   - Total records across all tables
#
# Returns:
#   0 on success
#   1 if database file not found
#
db_info() {
  info "Database Information" \
       "====================" \
       ''

  # Check if database exists
  if [[ ! -f "$DB_PATH" ]]; then
    error "Database file not found: $DB_PATH"
    info "  Create database by running: openxchg <base_currency>"
    return 1
  fi

  # Basic file information
  local -- db_size db_mtime
  db_size=$(stat -c%s "$DB_PATH")
  db_mtime=$(stat -c%y "$DB_PATH" | cut -d. -f1)

  info "Database File: $DB_PATH" \
       "File Size: $(numfmt --to=iec-i --suffix=B "$db_size" 2>/dev/null || echo "${db_size} bytes")" \
       "Last Modified: $db_mtime"

  # Get list of tables
  local -a tables
  mapfile -t tables < <(sqlite3 "$DB_PATH" "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name" 2>/dev/null)

  if ((${#tables[@]} == 0)); then
    info "No currency tables found in database"
    return 0
  fi

  info "Currency Tables (${#tables[@]} total)" \
       "------------------------------------"

  local -i total_records=0
  local -- table records min_date max_date last_updated currency_count

  for table in "${tables[@]}"; do
    # Get record count
    records=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM $table" 2>/dev/null || echo 0)

    if ((records > 0)); then
      # Get date range
      min_date=$(sqlite3 "$DB_PATH" "SELECT MIN(Date) FROM $table" 2>/dev/null || echo "N/A")
      max_date=$(sqlite3 "$DB_PATH" "SELECT MAX(Date) FROM $table" 2>/dev/null || echo "N/A")

      # Get last update timestamp
      last_updated=$(sqlite3 "$DB_PATH" "SELECT MAX(Updated) FROM $table" 2>/dev/null || echo "N/A")

      # Get count of unique currencies
      currency_count=$(sqlite3 "$DB_PATH" "SELECT COUNT(DISTINCT Currency) FROM $table" 2>/dev/null || echo 0)

      success "  $table:"
      info "    Records: $records" \
       "    Currencies: $currency_count" \
       "    Date Range: $min_date to $max_date" \
       "    Last Updated: $last_updated"

      ((total_records += records))
    else
      info "  $table: Empty"
    fi
  done

  info '' "Summary" "-------" \
       "Total Tables: ${#tables[@]}" \
       "Total Records: $total_records"

  # Calculate database efficiency
  if ((total_records > 0)); then
    local -i bytes_per_record
    bytes_per_record=$((db_size / total_records))
    info "Average Record Size: $bytes_per_record bytes"
  fi

  return 0
}

#
# db_vacuum - Optimize and compact database
#
# Performs SQLite VACUUM operation to:
#   - Reclaim unused space
#   - Defragment database file
#   - Rebuild indexes
#   - Improve query performance
#
# Returns:
#   0 on success
#   1 on failure
#
db_vacuum() {
  info "Database Optimization" "=====================" ''

  # Check if database exists
  if [[ ! -f "$DB_PATH" ]]; then
    error "Database file not found: $DB_PATH"
    return 1
  fi

  # Get size before vacuum
  local -i size_before
  size_before=$(stat -c%s "$DB_PATH")

  info "Database: $DB_PATH" \
       "Size Before: $(numfmt --to=iec-i --suffix=B "$size_before" 2>/dev/null || echo "${size_before} bytes")"
  info "Running VACUUM operation..."

  if sqlite3 "$DB_PATH" "VACUUM;" 2>/dev/null; then
    # Get size after vacuum
    local -i size_after
    size_after=$(stat -c%s "$DB_PATH")

    local -i size_diff=$((size_before - size_after))
    local -- percent_saved

    if ((size_before > 0)); then
      percent_saved=$(echo "scale=2; ($size_diff * 100) / $size_before" | bc)
    else
      percent_saved="0"
    fi

    success "VACUUM completed successfully"
    info "Results:" \
         "  Size After: $(numfmt --to=iec-i --suffix=B "$size_after" 2>/dev/null || echo "${size_after} bytes")" \
         "  Space Reclaimed: $(numfmt --to=iec-i --suffix=B "$size_diff" 2>/dev/null || echo "${size_diff} bytes") (${percent_saved}%)"

    return 0
  else
    error "VACUUM operation failed"
    return 1
  fi
}

#
# db_check - Verify database integrity
#
# Performs comprehensive integrity checks:
#   - SQLite integrity_check
#   - Schema validation
#   - Foreign key check (if enabled)
#   - Index validation
#
# Returns:
#   0 if all checks pass
#   1 if any check fails
#
db_check() {
  info "Database Integrity Check" "========================" ''

  # Check if database exists
  if [[ ! -f "$DB_PATH" ]]; then
    error "Database file not found: $DB_PATH"
    return 1
  fi

  info "Database: $DB_PATH"

  local -i errors=0

  # 1. SQLite integrity check
  info "1. SQLite Integrity Check" "-------------------------"

  local -- integrity_result
  integrity_result=$(sqlite3 "$DB_PATH" "PRAGMA integrity_check;" 2>&1)

  if [[ "$integrity_result" == "ok" ]]; then
    success "Database integrity: OK"
  else
    error "Database integrity: FAILED"
    info  "  Details: $integrity_result"
    ((errors+=1))
  fi

  # 2. Schema validation
  info "2. Schema Validation" "--------------------"

  local -a tables
  mapfile -t tables < <(sqlite3 "$DB_PATH" "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name" 2>/dev/null)

  if ((${#tables[@]} == 0)); then
    info "No tables found (empty database)"
  else
    local -i schema_errors=0
    local -- table expected_schema actual_schema

    for table in "${tables[@]}"; do
      # Check if table name is a valid 3-letter currency code
      if [[ ! "$table" =~ ^[A-Z]{3}$ ]]; then
        warn "Invalid table name (not 3-letter code): $table"
        ((schema_errors+=1))
        continue
      fi

      # Get table schema
      actual_schema=$(sqlite3 "$DB_PATH" ".schema $table" 2>/dev/null)

      # Check for required columns
      if [[ "$actual_schema" =~ "id INTEGER PRIMARY KEY" ]] && \
         [[ "$actual_schema" =~ "Date DATE NOT NULL" ]] && \
         [[ "$actual_schema" =~ "Currency TEXT NOT NULL" ]] && \
         [[ "$actual_schema" =~ "Unit INTEGER NOT NULL" ]] && \
         [[ "$actual_schema" =~ "Xchg REAL NOT NULL" ]] && \
         [[ "$actual_schema" =~ "Updated TIMESTAMP NOT NULL" ]]; then
        success "  $table: Schema valid"
      else
        error "  $table: Schema invalid or incomplete"
        ((schema_errors+=1))
        ((errors+=1))
      fi

      # Check for required indexes
      if [[ "$actual_schema" =~ "idx_${table}_currency" ]] && \
         [[ "$actual_schema" =~ "idx_${table}_updated" ]]; then
        : # Indexes present
      else
        warn "  $table: Missing indexes"
        ((schema_errors+=1))
      fi
    done

    if ((schema_errors == 0)); then
      success "All table schemas valid"
    else
      warn "Schema validation completed with $schema_errors issue(s)"
    fi
  fi

  # 3. Foreign key check
  info "3. Foreign Key Check" "--------------------"

  local -- fk_result
  fk_result=$(sqlite3 "$DB_PATH" "PRAGMA foreign_key_check;" 2>&1)

  if [[ -z "$fk_result" ]]; then
    success "No foreign key violations"
  else
    error "Foreign key violations found:"
    info "$fk_result"
    ((errors+=1))
  fi

  # 4. Quick count check
  info "4. Quick Count Check" "--------------------"

  local -i count_errors=0
  for table in "${tables[@]}"; do
    local -i count
    count=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM $table" 2>/dev/null || echo -1)

    if ((count < 0)); then
      error "  $table: Unable to count records"
      ((count_errors+=1))
      ((errors+=1))
    fi
  done

  if ((count_errors == 0)); then
    success "All tables readable"
  else
    error "$count_errors table(s) have read errors"
  fi

  # Summary
  info "Summary" "-------"

  if ((errors == 0)); then
    success "ALL CHECKS PASSED"
    return 0
  else
    error "CHECKS FAILED: $errors error(s) found"
    info "Recommendations:" \
      "  - Backup your database immediately" \
      "  - Try running: openxchg --db-vacuum" \
      "  - If problems persist, consider recreating affected tables"
    return 1
  fi
}

main() {
  local -- dte timestamp date mu base_currency
  local -a positional_args=()

  # First pass: check for -C/--config option to set custom config file
  local -a saved_args=("$@")
  while (($#)); do
    case $1 in
      -C|--config)
        [[ -n "${2:-}" ]] || die 1 "Option ${1@Q} requires an argument"
        CONFIG_FILE="$2"
        shift 2
        continue
        ;;
    esac
    shift
  done

  # Restore arguments for main parsing
  set -- "${saved_args[@]}"

  # Load system-wide configuration first (fallback mode - only sets unset values)
  load_config "$SYSTEM_CONFIG_FILE" "fallback"

  # Load user configuration file (normal mode - overrides system config)
  load_config "$CONFIG_FILE"

  # Check config file security if API key is set
  check_config_security "$CONFIG_FILE"

  # Apply config defaults (can be overridden by CLI options later)
  [[ -z "${CONFIG_DEFAULT_VERBOSE}" ]] || VERBOSE="${CONFIG_DEFAULT_VERBOSE}"
  [[ -z "${CONFIG_API_KEY}" ]] || OPENEXCHANGE_API_KEY="${CONFIG_API_KEY}"
  [[ -z "${CONFIG_DB_PATH}" ]] || DB_PATH="${CONFIG_DB_PATH}"
  [[ -n "${CONFIG_AUTO_UPDATE_CURRENCY_LIST}" ]] || CONFIG_AUTO_UPDATE_CURRENCY_LIST="true"

  # Load currency list (from JSON if available, otherwise hardcoded)
  load_currencies

  # Auto-update currencies if enabled and needed
  check_auto_update_currencies

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        exit 0
        ;;
      --version)
        echo "$SCRIPT_NAME $VERSION"
        exit 0
        ;;
      --init-config)
        create_default_config "$CONFIG_FILE"
        create_default_currency_list
        exit 0
        ;;
      --show-config)
        show_config
        exit 0
        ;;
      --check-config)
        validate_config "$CONFIG_FILE"
        exit $?
        ;;
      --db-info)
        db_info
        exit $?
        ;;
      --db-vacuum)
        db_vacuum
        exit $?
        ;;
      --db-check)
        db_check
        exit $?
        ;;
      -U|--update-currencies)
        fetch_currencies
        exit $?
        ;;
      -C|--config)
        # Already handled in first pass, skip argument
        [[ -n "${2:-}" ]] || die 1 "Option ${1@Q} requires an argument"
        shift
        ;;
      -v|--verbose)
        VERBOSE=1
        ;;
      -q|--quiet)
        VERBOSE=0
        ;;
      -d|--date)
        [[ -n "${2:-}" ]] || die 1 "Option ${1@Q} requires an argument"
        dte=$(TZ=UTC date +%F -d "$2" 2>/dev/null || echo '')
        [[ -n "$dte" ]] || die 1 "Invalid date format ${2@Q}"
        shift
        ;;
      -a|--apikey)
        [[ -n "${2:-}" ]] || die 1 "Option ${1@Q} requires an argument"
        OPENEXCHANGE_API_KEY="$2"
        shift
        ;;
      -l|--latest)
        LATEST_MODE=1
        ;;
      -A|--all)
        UPDATE_ALL_CURRENCIES=1
        ;;
      --)
        shift
        # Collect remaining args as positional
        while (($#)); do
          positional_args+=("$1")
          shift
        done
        break
        ;;
      -*)
        die 1 "Unknown option ${1@Q}"
        ;;
      *)
        # Collect non-option argument and continue parsing
        positional_args+=("$1")
        ;;
    esac
    shift
  done

  # Restore positional parameters
  set -- "${positional_args[@]}"

  # Validate option combinations
  if ((LATEST_MODE)) && [[ -n "${dte:-}" ]]; then
    die 1 'Options --latest and --date are mutually exclusive (latest fetches current rates)'
  fi

  # Set default date if not specified by -d option (always use UTC)
  # Use config value if set, otherwise default to 'yesterday'
  if [[ -z "${dte:-}" ]]; then
    local -- default_date_spec="${CONFIG_DEFAULT_DATE:-yesterday}"
    dte="$(TZ=UTC date +%F -d "$default_date_spec")"
  fi

  # Get base currency (use config default if not specified on command line)
  local -- default_base="${CONFIG_DEFAULT_BASE_CURRENCY:-IDR}"
  base_currency="${1:-$default_base}"
  base_currency=$(normalize_currency_code "$base_currency")
  (($#==0)) || shift

  # Ensure base currency table exists (creates if needed, not needed for LATEST mode)
  ((LATEST_MODE)) || ensure_table_exists "$base_currency"

  # LATEST MODE: Fetch and display current real-time rates (check before QUERY mode)
  if ((LATEST_MODE)); then
    local -- api_url="$OPENEXCHANGE_LATEST_URL?app_id=$OPENEXCHANGE_API_KEY"

    info "Fetching latest real-time rates for base currency: $base_currency"
    info "Note: These are current rates, not finalized End-of-Day values"

    wget -O "$TMPFILE" "$api_url" &>/dev/null \
      || die 1 "Failed to fetch latest rates from ${OPENEXCHANGE_LATEST_URL@Q}"

    # Parse JSON for rates and timestamp
    eval "$(jq -r '.rates | to_entries[] | "\(.key)=\(.value)"' "$TMPFILE")"
    local -i api_timestamp
    api_timestamp=$(jq -r '.timestamp' "$TMPFILE")

    # Convert Unix timestamp to human-readable UTC datetime
    local -- updated_time
    updated_time=$(TZ=UTC date -d "@$api_timestamp" '+%Y-%m-%d %H:%M:%S UTC')

    # Get base currency rate
    #shellcheck disable=SC2154
    local -- base_rate_var="${base_currency}"
    local -- base_rate="${!base_rate_var}"
    [[ -n "$base_rate" ]] || die 1 "Base currency $base_currency not found in API response"

    # Display header with timestamp
    info "Latest Exchange Rates (Real-time)" \
         "Base Currency: $base_currency" \
         "Updated: $updated_time"
    echo
    printf "%-10s  %-14s\n" "Currency" "Xchg"
    printf "%-10s  %-14s\n" "----------" "--------------"

    # Display rates (all currencies if none specified, or just requested ones)
    if [[ -n "${1:-}" ]]; then
      # Specific currencies requested
      while (($#)); do
        mu=$(normalize_currency_code "$1")
        local -- currency_rate="${!mu:-}"

        if [[ -n "$currency_rate" ]]; then
          local -- xchg
          xchg=$(bc <<< "scale=6; $base_rate/$currency_rate")
          # Format without trailing zeros
          xchg=$(echo "$xchg" | sed 's/0*$//' | sed 's/\.$//')
          printf "%-10s  %-14s\n" "$mu" "$xchg"
        else
          error "Currency $mu not found in API response"
        fi
        shift
      done
    else
      # Display all currencies
      local -- currency_rate xchg
      for mu in "${MU[@]}"; do
        currency_rate="${!mu:-}"
        [[ -n "$currency_rate" ]] || continue

        xchg=$(bc <<< "scale=6; $base_rate/$currency_rate")
        xchg=$(echo "$xchg" | sed 's/0*$//' | sed 's/\.$//')
        printf "%-10s  %-14s\n" "$mu" "$xchg"
      done
    fi

    return 0
  fi

  # QUERY MODE: Display rates for specified currencies
  if [[ -n "${1:-}" ]]; then
    # Print header once for all queries
    printf "%-10s  %-14s  %s\n" "Currency" "Xchg" "Date (UTC)"
    printf "%-10s  %-14s  %s\n" "----------" "--------------" "-----------"

    while (($#)); do
      mu=$(normalize_currency_code "$1")
      # Query SQLite and format output (avoid scientific notation with rtrim)
      sqlite3 -separator '|' "$DB_PATH" \
        "SELECT Currency,
                rtrim(rtrim(printf('%.6f', Xchg), '0'), '.') as Xchg,
                Date
         FROM $base_currency
         WHERE Date <= '$dte' AND Currency = '$mu'
         ORDER BY Date DESC
         LIMIT 1" | \
      while IFS='|' read -r currency xchg date; do
        printf "%-10s  %-14s  %s\n" "$currency" "$xchg" "$date"
      done
      shift
    done
    return 0
  fi

  # UPDATE MODE: Fetch currencies from API and populate database
  info "Base Currency: $base_currency"
  info "Date: $dte"

  # Get list of currencies to update (respects UPDATE_CURRENCIES config and --all flag)
  local -- update_list
  update_list=$(get_update_currency_list)
  local -a update_currencies
  read -ra update_currencies <<< "$update_list"

  local -i update_count=${#update_currencies[@]}
  local -i total_count=${#MU[@]}

  if ((update_count < total_count)); then
    info "Updating ${update_count}/${total_count} currencies (selective mode)"
  else
    info "Updating all ${total_count} currencies"
  fi

  wget -O "$TMPFILE" "$OPENEXCHANGE_HISTORICAL_URL/$dte.json?app_id=$OPENEXCHANGE_API_KEY" &>/dev/null \
      || die 1 "Bad Date? Expired API Key? No data returned from ${OPENEXCHANGE_HISTORICAL_URL@Q}"

  # Parse JSON using jq and create bash variables (e.g., USD=1.0, EUR=0.86)
  eval "$(jq -r '.rates | to_entries[] | "\(.key)=\(.value)"' "$TMPFILE")"

  date="$dte"
  echo

  # Get base currency rate from API response
  #shellcheck disable=SC2154
  local -- base_rate_var="${base_currency}"
  local -- base_rate="${!base_rate_var}"

  [[ -n "$base_rate" ]] || die 1 "Base currency $base_currency not found in API response"

  # Process each currency in the update list
  local -- currency_rate xchg
  local -i processed=0
  for mu in "${update_currencies[@]}"; do
    currency_rate="${!mu:-}"  # Use :- to handle missing currencies gracefully

    # Skip if currency rate not available in API response
    if [[ -z "$currency_rate" ]]; then
      warn "Currency $mu not found in API response, skipping"
      continue
    fi

    # Calculate exchange rate relative to base currency
    # Example: If base=IDR and currency=USD, calculate IDR/USD ratio
    xchg=$(bc <<< "scale=6; $base_rate/$currency_rate")

    # Insert or replace in SQLite database table
    # Note: CURRENT_TIMESTAMP is in UTC (SQLite default behavior)
    sqlite3 "$DB_PATH" \
      "INSERT OR REPLACE INTO $base_currency (Date, Currency, Unit, Xchg, Updated)
       VALUES ('$date', '$mu', 1, $xchg, CURRENT_TIMESTAMP)"

    ((processed+=1))
    ((VERBOSE==0)) || info "Updated: $mu $date xchg=$xchg"
  done

  info "Update complete: ${processed}/${update_count} currencies processed for $date ($base_currency table)"
}

cleanup() {
  local -i err=${1:=$?}
  rm -f "$TMPFILE"
  exit $err
}

usage() {
  cat <<'ETX'
openxchg - Multi-currency exchange rate database manager

Fetches exchange rates from openexchangerates.org and stores them in SQLite.
Each base currency gets its own table (e.g., IDR, USD, EUR, GBP). Supports
169 currencies. Currency codes are case-insensitive. Options can appear
anywhere in the command line.

Usage: openxchg [OPTIONS] [base_currency] [CurrencyCode]...

Options:
  -h, --help          Display this help message and exit
  --version           Display version information and exit
  -v, --verbose       Enable verbose output (default)
  -q, --quiet         Disable verbose output
  -d, --date DATE     Specify date for query/update (default: yesterday UTC)
  -a, --apikey KEY    Use custom API key (overrides OPENEXCHANGE_API_KEY env)
  -l, --latest        Fetch and display current real-time rates (display-only)
  -A, --all           Update all currencies (overrides UPDATE_CURRENCIES config)
  -C, --config FILE   Use alternative config file (default: ~/.config/openxchg/config)
  --init-config       Create default config file (backs up existing)
  --show-config       Display current effective configuration
  --check-config      Validate configuration file (syntax, values, security)
  --db-info           Display database statistics and information
  --db-vacuum         Optimize and compact database (reclaim space)
  --db-check          Verify database integrity and schema
  -U, --update-currencies  Fetch and update currency list from API

Arguments:
  base_currency       Base currency (default: IDR, case-insensitive)
  CurrencyCode        Currency codes to query (case-insensitive)

Modes:
  UPDATE: No currency codes given - fetches all rates for specified date
  QUERY:  Currency codes given - displays rates from database
  LATEST: With --latest flag - fetches current real-time rates (not stored)

Examples:
  # Query latest rates (yesterday) - case-insensitive
  openxchg idr usd eur gbp
  openxchg AUD usd sgd

  # Query specific date
  openxchg -d 2025-01-01 EUR usd gbp aud
  openxchg eur -d today usd gbp      # Options can appear anywhere

  # Update database for yesterday (all 169 currencies)
  openxchg idr                       # Updates IDR table
  openxchg eur                       # Updates EUR table
  openxchg gbp                       # Updates GBP table

  # Update specific date
  openxchg -d 2025-01-01 usd
  openxchg aud -d 2020-05-15         # Options anywhere works!

  # Custom API key
  openxchg -a YOUR_KEY eur
  OPENEXCHANGE_API_KEY=YOUR_KEY openxchg eur

  # Quiet mode (no progress messages)
  openxchg -q idr usd eur
  openxchg -q -d yesterday eur       # Update quietly

  # Display current real-time rates
  openxchg --latest idr usd eur gbp
  openxchg -l aud usd sgd

  # Display all latest rates for base currency
  openxchg --latest eur              # Shows all 169 currencies

  # Quiet latest rates
  openxchg -q --latest idr usd eur

  # Version info
  openxchg --version

  # Configuration management
  openxchg --init-config             # Create default config file
  openxchg --show-config             # Display effective configuration
  openxchg --check-config            # Validate configuration file
  openxchg -C /path/to/config idr    # Use custom config file

  # Currency management
  openxchg -U                        # Fetch/update currency list from API
  openxchg --update-currencies       # Same as -U

  # Selective currency updates
  openxchg idr                       # Updates currencies per UPDATE_CURRENCIES config
  openxchg --all idr                 # Override config, update all 173 currencies
  openxchg -A eur                    # Same as --all (short form)

  # Database management
  openxchg --db-info                 # Display database statistics
  openxchg --db-vacuum               # Optimize and compact database
  openxchg --db-check                # Verify database integrity

Configuration:
  Config file: ~/.config/openxchg/config (INI format)

  The script loads settings from the config file if it exists. Command-line
  options always override config file settings.

  Precedence (highest to lowest):
    1. Command-line options
    2. Config file settings
    3. Environment variables (API key only)
    4. Built-in defaults

  Supported settings:
    [General]
      DEFAULT_BASE_CURRENCY     - Default base currency (default: IDR)
      DEFAULT_VERBOSE           - Verbosity 0=quiet, 1=verbose (default: 1)
      DEFAULT_DATE              - Default date: yesterday, today, YYYY-MM-DD (default: yesterday)
      AUTO_UPDATE_CURRENCY_LIST - Auto-update currencies daily: true/false (default: true)
      UPDATE_CURRENCIES         - Currencies to update: ALL, CONFIGURED, or file path (default: ALL)

    [API]
      API_KEY                   - OpenExchangeRates API key (recommended: use env var)

    [Database]
      DB_PATH                   - Database file path (default: xchg.db in script dir)

  Currency List Management:
    The script maintains a currency list in ~/.config/openxchg/currencies.json

    - Use -U to fetch the latest list from OpenExchangeRates API (169+ currencies)
    - If AUTO_UPDATE_CURRENCY_LIST=true, automatically updates once per day
    - Falls back to hardcoded list if currencies.json doesn't exist
    - No API key required for currency list updates

  Selective Currency Updates:
    Control which currencies are updated in UPDATE mode using UPDATE_CURRENCIES:

    - ALL (default): Update all 173 currencies
    - CONFIGURED: Update currencies from currencies.json
    - /path/to/file: Custom list (one currency per line)

    Example setup:
      1. openxchg --init-config                 # Creates update-currencies.list.example
      2. cp ~/.config/openxchg/update-currencies.list.example \
            ~/.config/openxchg/update-currencies.list
      3. Edit update-currencies.list to your needs
      4. Set UPDATE_CURRENCIES=update-currencies.list in config
      5. openxchg idr                           # Updates only listed currencies

    Override with --all flag to temporarily update all currencies:
      openxchg --all idr                        # Ignores UPDATE_CURRENCIES setting

    Note: QUERY mode can access any currency in database regardless of update list

  Security:
    If API_KEY is set in config file, ensure file mode is 0600 (owner read/write only).
    The script will warn if permissions are too open but will continue execution.

  First-time setup:
    openxchg --init-config   # Creates config file with defaults and examples
    vi ~/.config/openxchg/config  # Edit to customize your settings

Output Format:
  Currency    Xchg            Date (UTC)
  ----------  --------------  -----------
  USD         16712           2025-11-14
  EUR         19426.865616    2025-11-14
  GBP         21989.647286    2025-11-14

Database:
  Location: /usr/share/okusi/getkurs/xchg.db
  Tables:   One per base currency (IDR, USD, EUR, etc.)
  Columns:  id, Date, Currency, Unit, Xchg, Updated

Timezone:
  All dates are in UTC timezone, matching the OpenExchange API convention.
  Relative dates (yesterday, today, 3 days ago) are calculated in UTC.
  The API provides End-of-Day (EOD) rates for completed UTC days.

  Note: Database records created before UTC implementation may contain
        dates calculated in local timezone (WITA, UTC+8).

Latest Mode:
  The --latest option fetches current real-time exchange rates directly from
  the API and displays them immediately. These rates are NOT stored in the
  database and are NOT finalized End-of-Day (EOD) values. Use this for
  quick reference of current market rates.

  Latest rates include a timestamp showing when they were last updated by
  the OpenExchangeRates API (typically updated hourly during market hours).

  Note: --latest and --date options are mutually exclusive. Latest mode
  always fetches the most recent available rates.
ETX
}

main "$@"
#fin
